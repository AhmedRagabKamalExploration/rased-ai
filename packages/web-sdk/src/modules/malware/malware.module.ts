import { BaseModule } from "@/modules/BaseModule";
import { SHA256 } from "crypto-js";

export class MalwareModule extends BaseModule {
  public readonly moduleName: string = "malware";

  /**
   * Initializes malware detection. This is an async operation that performs
   * a snapshot scan of the page's content at two points in time.
   */
  public async init(): Promise<void> {
    console.log(`[SDK] ${this.moduleName}: Initializing...`);
    try {
      const initialPayload = this.collectInitialMalwareData();
      this.eventManager.dispatch(this.moduleName, "malware", initialPayload);

      // Perform a second scan after a short delay to catch dynamically injected scripts.
      setTimeout(() => {
        const postLoadPayload = this.collectPostLoadMalwareData();
        this.eventManager.dispatch(this.moduleName, "malware", postLoadPayload);
      }, 5000); // 5-second delay to simulate post-load injection
    } catch (error) {
      console.error(`[SDK] ${this.moduleName}: Collection failed.`, error);
      this.eventManager.dispatch(this.moduleName, "malware.error", {
        error: "Malware collection failed",
        errorCode: "DOM_SCAN_FAILED",
        details: {
          message: (error as Error).message,
        },
      });
    }
  }

  /**
   * Collects malware data from the initial page load state.
   */
  private collectInitialMalwareData(): any {
    const inlineScripts = this.getInlineScripts(document.head);
    const externalScripts = this.getExternalScripts(document.head);
    const inputFields = this.getInputFields();
    const hasIFrame = this.checkIframePresence();

    const payload = {
      hostSite: window.location.hostname,
      urls: externalScripts,
      numberOfInputFields: inputFields.length,
      inputFields: inputFields,
      hasIFrame: hasIFrame,
      inlineJavaScriptContent: inlineScripts,
      timestamp: Date.now(),
    };

    return payload;
  }

  /**
   * Collects malware data after a delay to catch dynamic injections.
   */
  private collectPostLoadMalwareData(): any {
    const inlineScripts = this.getInlineScripts(document.body);
    const postLoadPayload = {
      postLoadJavaScriptContent: inlineScripts,
      timestamp: Date.now(),
    };
    return postLoadPayload;
  }

  /**
   * Finds and hashes the content of inline <script> tags.
   */
  private getInlineScripts(element: HTMLElement): { content: string }[] {
    const scripts = element.querySelectorAll("script");
    const inlineContent: { content: string }[] = [];

    scripts.forEach((script) => {
      if (!script.src && script.innerHTML.trim() !== "") {
        // Hash the script content to anonymize it.
        const contentHash = SHA256(script.innerHTML).toString();
        inlineContent.push({ content: contentHash });
      }
    });

    return inlineContent;
  }

  /**
   * Finds and validates external script URLs.
   */
  private getExternalScripts(element: HTMLElement): any[] {
    const scripts = element.querySelectorAll("script");
    const urls: any[] = [];
    const host = window.location.hostname;

    scripts.forEach((script) => {
      if (script.src) {
        const url = new URL(script.src);
        const urlString = url.toString();
        urls.push({
          url: urlString,
          length: urlString.length,
          htmlSection: element.tagName === "HEAD" ? "HEAD" : "BODY",
          isSuspiciouslyLong: urlString.length > 255, // A heuristic for suspicious URLs
          isCrossDomain: url.hostname !== host,
          containsIPAddress: !!url.hostname.match(/\d{1,3}(\.\d{1,3}){3}/),
          isExecutable: true,
          isMalicious: false, // This is determined on the backend
        });
      }
    });

    return urls;
  }

  /**
   * Finds input fields and hashes their sensitive attributes.
   */
  private getInputFields(): any[] {
    const inputs: any[] = [];
    const inputElements = document.querySelectorAll("input, select, textarea");

    inputElements.forEach((input) => {
      const rect = input.getBoundingClientRect();
      const labels = this.getLabelsForInput(input);

      inputs.push({
        id: SHA256(input.id).toString(),
        label: SHA256(labels.join(",")).toString(),
        top: rect.top,
        right: rect.right,
        bottom: rect.bottom,
        left: rect.left,
      });
    });

    return inputs;
  }

  /**
   * Helper to find associated labels for an input element.
   */
  private getLabelsForInput(input: Element): string[] {
    const labels = document.querySelectorAll(`label[for="${input.id}"]`);
    return Array.from(labels).map((label) => label.textContent || "");
  }

  /**
   * Checks for the presence of iframes in the document.
   */
  private checkIframePresence(): boolean {
    return document.querySelectorAll("iframe").length > 0;
  }
}
