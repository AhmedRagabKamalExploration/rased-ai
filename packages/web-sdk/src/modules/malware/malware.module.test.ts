import { describe, it, expect, beforeEach, vi, afterEach } from "vitest";

// Mock crypto-js first
vi.mock("crypto-js", () => ({
  SHA256: vi.fn().mockImplementation(() => ({
    toString: vi.fn().mockReturnValue("mocked-hash-123456789"),
  })),
}));

import { MalwareModule } from "./malware.module";
import { EventManager } from "@/managers/EventManager";

// Mock EventManager
const mockEventManager = {
  dispatch: vi.fn(),
};

vi.mock("@/managers/EventManager", () => ({
  EventManager: {
    getInstance: vi.fn(() => mockEventManager),
  },
}));

describe("MalwareModule", () => {
  let malwareModule: MalwareModule;
  let mockDocument: any;
  let mockWindow: any;

  beforeEach(async () => {
    vi.clearAllMocks();

    // Mock EventManager.getInstance to return our mock
    (EventManager.getInstance as any).mockReturnValue(mockEventManager);

    // Mock crypto-js SHA256 directly
    const { SHA256 } = await import("crypto-js");
    vi.mocked(SHA256).mockImplementation(
      (_input) =>
        ({
          toString: vi.fn().mockReturnValue("mocked-hash-123456789"),
        }) as any
    );

    // Mock document
    const mockScript = {
      src: "",
      innerHTML: "console.log('test');",
      getBoundingClientRect: vi.fn().mockReturnValue({
        top: 10,
        right: 100,
        bottom: 30,
        left: 5,
      }),
    };

    const mockInput = {
      id: "test-input",
      getBoundingClientRect: vi.fn().mockReturnValue({
        top: 10,
        right: 100,
        bottom: 30,
        left: 5,
      }),
    };

    const mockLabel = {
      textContent: "Test Label",
    };

    mockDocument = {
      head: {
        querySelectorAll: vi.fn().mockReturnValue([mockScript]),
      },
      body: {
        querySelectorAll: vi.fn().mockReturnValue([mockScript]),
      },
      querySelectorAll: vi.fn().mockImplementation((selector) => {
        if (selector === "script") return [mockScript];
        if (selector === "input, select, textarea") return [mockInput];
        if (selector === "iframe") return [];
        if (selector === `label[for="${mockInput.id}"]`) return [mockLabel];
        return [];
      }),
    };

    global.document = mockDocument;

    // Mock window
    mockWindow = {
      location: {
        hostname: "example.com",
      },
    };

    global.window = mockWindow;

    // Mock console methods
    global.console = {
      ...console,
      log: vi.fn(),
      error: vi.fn(),
    };

    // Mock setTimeout to store the callback for later execution
    vi.spyOn(global, "setTimeout").mockImplementation((callback, _delay) => {
      // Store the callback for later execution in tests
      (global as any).storedCallback = callback;
      return 1 as any;
    });

    malwareModule = new MalwareModule();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe("moduleName", () => {
    it("should have correct module name", () => {
      expect(malwareModule.moduleName).toBe("malware");
    });
  });

  describe("init", () => {
    it("should initialize successfully and dispatch malware data", async () => {
      await malwareModule.init();

      expect(mockEventManager.dispatch).toHaveBeenCalledWith(
        "malware",
        "malware",
        expect.objectContaining({
          hostSite: "example.com",
          urls: expect.any(Array),
          numberOfInputFields: expect.any(Number),
          inputFields: expect.any(Array),
          hasIFrame: expect.any(Boolean),
          inlineJavaScriptContent: expect.any(Array),
          timestamp: expect.any(Number),
        })
      );
    });

    it("should dispatch post-load data after timeout", async () => {
      await malwareModule.init();

      // Check that setTimeout was called
      expect(global.setTimeout).toHaveBeenCalledWith(
        expect.any(Function),
        5000
      );

      // Manually trigger the stored callback to simulate timeout
      const storedCallback = (global as any).storedCallback;
      if (storedCallback) {
        storedCallback();
      }

      // Check that post-load data was dispatched
      expect(mockEventManager.dispatch).toHaveBeenCalledWith(
        "malware",
        "malware",
        expect.objectContaining({
          postLoadJavaScriptContent: expect.any(Array),
          timestamp: expect.any(Number),
        })
      );
    });

    it("should handle collection errors gracefully", async () => {
      // Mock document.head to throw error
      Object.defineProperty(global.document, "head", {
        get: () => {
          throw new Error("DOM access denied");
        },
        configurable: true,
      });

      await malwareModule.init();

      expect(mockEventManager.dispatch).toHaveBeenCalledWith(
        "malware",
        "malware.error",
        expect.objectContaining({
          error: "Malware collection failed",
          errorCode: "DOM_SCAN_FAILED",
          details: expect.objectContaining({
            message: "DOM access denied",
          }),
        })
      );
    });
  });

  describe("collectInitialMalwareData", () => {
    it("should collect initial malware data correctly", () => {
      // Access private method through any type
      const result = (malwareModule as any).collectInitialMalwareData();

      expect(result).toEqual({
        hostSite: "example.com",
        urls: expect.any(Array),
        numberOfInputFields: expect.any(Number),
        inputFields: expect.any(Array),
        hasIFrame: expect.any(Boolean),
        inlineJavaScriptContent: expect.any(Array),
        timestamp: expect.any(Number),
      });
    });
  });

  describe("collectPostLoadMalwareData", () => {
    it("should collect post-load malware data correctly", () => {
      // Access private method through any type
      const result = (malwareModule as any).collectPostLoadMalwareData();

      expect(result).toEqual({
        postLoadJavaScriptContent: expect.any(Array),
        timestamp: expect.any(Number),
      });
    });
  });

  describe("getInlineScripts", () => {
    it("should find and hash inline script content", () => {
      const mockElement = {
        querySelectorAll: vi.fn().mockReturnValue([
          {
            src: "",
            innerHTML: "console.log('test');",
          },
        ]),
      };

      // Access private method through any type
      const result = (malwareModule as any).getInlineScripts(mockElement);

      expect(result).toEqual([
        {
          content: "mocked-hash-123456789",
        },
      ]);
    });

    it("should skip scripts with src attribute", () => {
      const mockElement = {
        querySelectorAll: vi.fn().mockReturnValue([
          {
            src: "https://example.com/script.js",
            innerHTML: "console.log('test');",
          },
        ]),
      };

      // Access private method through any type
      const result = (malwareModule as any).getInlineScripts(mockElement);

      expect(result).toEqual([]);
    });

    it("should skip empty scripts", () => {
      const mockElement = {
        querySelectorAll: vi.fn().mockReturnValue([
          {
            src: "",
            innerHTML: "",
          },
        ]),
      };

      // Access private method through any type
      const result = (malwareModule as any).getInlineScripts(mockElement);

      expect(result).toEqual([]);
    });
  });

  describe("getExternalScripts", () => {
    it("should find and analyze external script URLs", () => {
      const mockElement = {
        querySelectorAll: vi.fn().mockReturnValue([
          {
            src: "https://example.com/script.js",
          },
        ]),
        tagName: "HEAD",
      };

      // Access private method through any type
      const result = (malwareModule as any).getExternalScripts(mockElement);

      expect(result).toEqual([
        {
          url: "https://example.com/script.js",
          length: expect.any(Number),
          htmlSection: "HEAD",
          isSuspiciouslyLong: false,
          isCrossDomain: false,
          containsIPAddress: false,
          isExecutable: true,
          isMalicious: false,
        },
      ]);
    });

    it("should detect suspicious URLs", () => {
      const mockElement = {
        querySelectorAll: vi.fn().mockReturnValue([
          {
            src:
              "https://192.168.1.1/very-long-script-name-that-exceeds-255-characters-" +
              "x".repeat(200) +
              ".js",
          },
        ]),
        tagName: "HEAD",
      };

      // Access private method through any type
      const result = (malwareModule as any).getExternalScripts(mockElement);

      expect(result[0].isSuspiciouslyLong).toBe(true);
      expect(result[0].containsIPAddress).toBe(true);
    });
  });

  describe("getInputFields", () => {
    it("should find and analyze input fields", () => {
      // Access private method through any type
      const result = (malwareModule as any).getInputFields();

      expect(result).toEqual([
        {
          id: "mocked-hash-123456789",
          label: "mocked-hash-123456789",
          top: 10,
          right: 100,
          bottom: 30,
          left: 5,
        },
      ]);
    });
  });

  describe("getLabelsForInput", () => {
    it("should find associated labels for input", () => {
      const mockInput = { id: "test-input" };

      // Access private method through any type
      const result = (malwareModule as any).getLabelsForInput(mockInput);

      expect(result).toEqual(["Test Label"]);
    });
  });

  describe("checkIframePresence", () => {
    it("should detect iframe presence", () => {
      // Access private method through any type
      const result = (malwareModule as any).checkIframePresence();

      expect(result).toBe(false);
    });

    it("should return true when iframes are present", () => {
      mockDocument.querySelectorAll = vi.fn().mockImplementation((selector) => {
        if (selector === "iframe") return [{ tagName: "IFRAME" }];
        return [];
      });

      // Access private method through any type
      const result = (malwareModule as any).checkIframePresence();

      expect(result).toBe(true);
    });
  });

  describe("integration", () => {
    it("should handle complete malware detection flow", async () => {
      await malwareModule.init();

      // Manually trigger the stored callback to simulate timeout
      const storedCallback = (global as any).storedCallback;
      if (storedCallback) {
        storedCallback();
      }

      expect(mockEventManager.dispatch).toHaveBeenCalledTimes(2); // Initial + post-load
      expect(mockEventManager.dispatch).toHaveBeenCalledWith(
        "malware",
        "malware",
        expect.objectContaining({
          hostSite: "example.com",
          timestamp: expect.any(Number),
        })
      );
    });
  });
});
